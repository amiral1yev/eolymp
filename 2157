MOD = 1000000000  # Определение константы

g = []  # Список смежности
res = 0  # Переменная для хранения результата
n = int(input())  # Количество вершин

# Чтение графа в виде списка смежности
g = [[] for _ in range(n + 1)]  # Список смежности с индексом от 1
for _ in range(n - 1):
    u, v, d = map(int, input().split())
    g[u].append((v, d))
    g[v].append((u, d))

def dfs(v, p=-1):
    cnt = 1  # Начинаем с подсчета самой вершины
    for to, w in g[v]:  # Для каждого соседнего узла
        if to != p:  # Чтобы не возвращаться в родительскую вершину
            c = dfs(to, v)  # Рекурсивный вызов для дочерней вершины
            global res
            res = (res + c * (n - c) * w) % MOD  # Обновляем результат
            cnt += c  # Увеличиваем количество вершин в поддереве
    return cnt

# Запуск поиска в глубину с вершины 1
dfs(1)

# Выводим результат
print(res)
